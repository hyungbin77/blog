
### 알고리즘 소개 

JAGS를 사용하여 전염병 모델과 같은 베이지안 모델을 정의할 때, 데이터를 모델에 어떻게 연결하느냐, 즉 인덱싱(indexing) 방식은 계산 효율성에 큰 영향을 미침. 특히, 모델이 복잡해지고 데이터가 커질수록, 인덱싱 방식에 따른 계산 시간 차이는 무시할 수 없음. 이전에 사용하던 인덱싱 방법과 본 논문에서 제시하는 2D indexing을 비교 분석함

#### 1D nested indexing 
- 모든 관측치(observations)를 하나의 인덱스로 나타내고, 각 관측치가 어떤 공간에 속하는지에 대한 정보는 별도의 벡터(index vector)에 저장함
- 이 방식은 모델 텍스트가 직관적이지만, 공간 정보를 참조하기 위해 추가적인 연산이 필요하며, 특히 ifelse() 문을 자주 사용하게 되어 계산 효율성을 저하시킬 수 있음 
- $index(i)$ 는 i번째 관측치가 어떤 공간에  속하는지를 나타내는 별도의 벡터
- $theta[index(i)]$ 와 $phi[index[i]]$ 는 i번째 관측치에 해당하는 공간의 $theta$ 와 $phi$ 값을 가져오기 위해 $index$ 벡터를 사용함 

#### 2D indexing 
- 시간 인덱스와 공간 인덱스를 별도로 사용하여 데이터를 2차원 array 형태로 나타냄
	- 예를 들어, 5개 지역(s = 1,2,3,4,5)에서 10개 시점(t = 1,2,...,10)에 걸쳐 전염병 발생 건수를 관측했다면, 시간 인덱스 t와 공간 인덱스 s를 사용하여 데이터를 z[t,s]와 같이 2차원 배열로 표현함 
- 이 방식은 데이터의 구조를 직접 반영하며, 공간 정보를 참조하기 위한 추가 연산이 필요하지 않음
	- 별도의 index 벡터 없이 공간 인덱스 s를 직접 사용하여 해당 지역의 모수(parameter) 값을 가져올 수 있어 효율적(theta[s]는 s 번째 지역에 대한 theta 값을 나타냄 )
- $lambda[t,s]$ 는 시간 t, 공간 s 에서의 감염률을 나타내며, 시간과 공간을 직접 인덱스로 사용
- $theta[s]$ 와 $phi[s]$ 는 s 번째 공간에 대한 값을 나타내며, 별도의 index 벡터 없이 공간 인덱스 s를 직접 사용함 

![[Pasted image 20241218175020.png]]


![[Pasted image 20241218185019.png]]
- Fig 3. 을 보면 1D nested indexing은 index 벡터를 사용하고, 공간정보를 간접적으로 참초하기 때문에 노드가 더 많음
- 1D는 theta[index(i)], phi[index(i)] 와 같이 index(i) 를 통해 간접적으로 공간 정보를 참조함
- 2D는 theta[s], phi[s] 와 같이 공간 인덱스 s를 사용하여 직접 공간 정보를 참조함 




### 사전 분포와(Prior Distributions)와 계산 효율성

1. 사전 분포의 매개변수(parameter) 수 
	- 사전 분포의 매개변수 수가 많을 수록, 모델은 더 복잡해짐 
	- DAG의 크기를 증가시키고, 알고리즘 복잡도를 높여 실행 시간이 늘어나는 결과를 초래함 
2. 난수 생성(random number generation) 복잡성
	- JAGS는 MCMC 샘플링 과정에서 사전 분포로부터 난수를 생성 
	- 어떤 사전 분포는 다른 사전 분포보다 난수를 생성하기 더 복잡하고, 이는 계산 시간에 영향을 줌

- 사전 분포의 변화는 2D indexing과 1D nested indexing 간의 상대적인 효율성 비교에는 영향을 주지 않음
	- 두 인덱싱은 데이터를 모델에 연결하는 방식만 다를 뿐, 모델의 확률적 구조(stocahstic structure) 자체는 동일함. 즉, 두 인덱싱 방식 모두에서 동일한 사전 분포가 사용됨 
	- DAG를 연결하는 구조만 다를뿐, DAG에서 확률적 변수(stocahastic variables)와 그들의 의존성을 나타내는 부분은 동일함 
### ifelse() 문의 사용과 계산 효율성 

![[Pasted image 20241218180005.png| 500]]

#### 1D nested indexing에서 ifelse() 문을 많이 사용하는 이유 
- 1D indexing에서는 모든 관측치(t,s)를 하나의 인덱스(i)로 나타냄. 즉, 데이터 자체가 어떤 관측치가 어떤 공간(s)에 속하는지 직접적으로 나타내지 않음
- 각 관측치에 해당하는 공간 정보를 연결하기 위해 index(i) 함수를 사용하고, 이 정보를 $theta[index(i)]$ 와 같이 사용하여 공간 정보를 가져옴 
- fig(10,11) 와 같이 특정 지역 (s = 10,14,26,33,45,52,74,76)에 대해 다른 시간 추세를 적용해야함
- 1D indexing에서는 어떤 관측치(i)가 어떤 공간(s)에 속하는지 바로 알 수 없기 때문에 ifelse()문을 사용하여 각 관측치(i)마다 해당 지역인지 아닌지 매번 확인 해야함 (fig.10에선 ifelse ((i <= 2409) && (i >= 2337))...
- 즉, 모든 관측치에 대해 ifelse()문을 실행하고, 해당 지역이면(true) 해당 지역에 맞는 계산식을, 아니면(false) 다른 계산식을 적용해야함

![[Pasted image 20241218181228.png|500]]


#### 2D indexing에서 ifelse() 문 사용이 적은 이유
- 2D indexing 에서는 시간(t) 와 공간(s)을 각각 별도의 인덱스로 사용. 즉, 데이터 자체가 어떤 관측치가 어떤 공간(s)에 속하는지 직접적으로 나타냄 
- Fig 9에서는  for(s == 10 || s == 14 || ...)와 같이 해당 공간(s)이 특정 지역인지 여부를 확인하고, 그 결과에 따라 해당 지역에 맞는 계산식 또는 다른 계산식을 적용 
- 즉, 각 공간(s)에 대해서만 ifelse() 문을 실행 





### less ifelse() with TSmodel

![[Pasted image 20241218181016.png|500]]
![[Pasted image 20241218180753.png|500]]

- TSmodel : 1D, 2D 이 특정 지역(Fig 11, 12에선 s = 10,14, 26, 33, 45, 52, 74, 76)에 속하는지 여부(1또는 0)을 미리 계산하여 저장한 indicator variable
> TSmodel <- array(0,N)
> TSmodel[658:730] <- 1 ; TSmodel[950:1022] <- 1
> TSmodel[5257:5329] <- 1 : TSmodel[1826:1898] <- 1
- TSmodel을 사용하면 ifelse() 문 내의 복잡한 조건물을 TSmodel[i] ==1 (1D) 또는 TSmodel[s] ==1 (2D)과 같이 바꿀 수 있다. 
- 1D에서 TSmodel을 사용시 모든 관측치 i에 대해 매번 ifelse()문을 실행할 필요가 없어지기 때문에 반복문이 더 긴 특성상 효과가 더 큼 


![[Pasted image 20241218182447.png|500]]
- Fig 13은 1D nested indexing과 2D indexing을 사용했을 때, 그리고 ifelse()문 사용을 최소화했을 때의 계산 효율성을 비교한 결과이다
- 2D 인덱싱은 1D nested indexing에 비해 DAG의 크기가 훨씬 작음. 이는 2D 인덱싱이 데이터를 모델에 더 효율적으로 연결하고, 불필요한 노드와 엣지를 줄이기 때문 
- ifelse() 문을 최소화하더라도, 2D 인덱싱의 DAG 크기가 여전히 1D 중첩 인덱싱보다 작고 , 계산 효율성이 좋음 



**

인덱싱에서는 모든 관측치 i에 대해 ifelse() 문을 실행해야 했지만, 2D 인덱싱에서는 각 지역 s에 대해서만 ifelse() 문을 실행하면 되므로, ifelse() 문의 실행 횟수가 크게 줄어든다

**


TSmodel

ifelse() 문 사용을 더욱 줄이고 계산 효율성을 높이기 위해, 본 연구에서는 TSmodel 이라는 사전에 계산된 지시 변수를 도입한다. TSmodel은 각 관측치(1D 인덱싱) 또는 각 지역(2D 인덱싱)이 특정 지역(본 연구에서는 s = 10, 14, 26, 33, 45, 52, 74, 76)에 속하는지 여부를 나타내는 지시변수이다.


TSmodel을 사용하면 ifelse() 문의 조건이 TSmodel[i] == 1 (1D 인덱싱) 또는 TSmodel[s] == 1 (2D 인덱싱)로 매우 간단진다. 이는 그림 Fig10과 Fig9의 ifelse문 속 ((i <= 2409) && (i >= 2337)) || ((i <= 1022) && (i >= 950)) || ... 또는 (s == 10 || s == 14 || ... 와 같은 복잡한 조건 계산을 TSmodel 변수 확인이라는 간단한 연산으로 대체할 수 있음을 의미한다. 또한, TSmodel은 사전에 계산되므로, JAGS는 ifelse() 문을 실행할 때마다 특정 지역 여부를 반복적으로 계산할 필요가 없없다. TSmodel 값을 한 번만 확인하면 되므로, 중복 계산을 없애고 계산 시간을 단축한다.



Fig 13의 결과는 ifelse() 문 최소화 전략, 특히 TSmodel의 활용이 계산 효율성 향상에 효과적임을 보여준다. ifelse() 문을 최소화한 2D 인덱싱(Result using 2D indexing, less ifelse())은 그렇지 않은 경우(Result using 2D indexing)에 비해 DAG 크기가 감소하고 실행 시간이 단축되었다.(124041 → 123413, 19.01 hours → 16.10 hours) ifelse() 문을 최소화한 1D 인덱싱(Result using 1D nested indexing, less ifelse())은 그렇지 않은 경우(Result using 1D nested indexing)에 비해 DAG 크기가 크게 감소하고 실행 시간이 획기적으로 단축되었다.(227138 → 134867, 199.56 hours → 37.17 hours) 더욱이, ifelse() 문을 최소화하더라도, 2D 인덱싱의 DAG 크기가 여전히 1D 인덱싱보다 작고, 실행 시간도 더 빠르다. (123413 < 134867, 16.10 hours < 37.17 hours)


---

- 논문 소개 part 
- DAGS , GeoJax, precision car 
	- 정의 ,언급 정도 
효율성 









내일 밤 10시 
형식 결론쪽 
~ ~다  형식 


숫자로만 인덱싱 



결론에 보안점 한계점,, 마저 못썻던 내용 적기


### 2. 논문 소개

#### 2.1 알고리즘을 알기위한 배경 지식 

본 논문에서는 전염병의 시공간적 확산을 모델링하기 위해 베이지안 계층적 모델(Bayesian hierarchical models)을 사용하며, 이를 구현하기 위해 JAGS(Just Another Gibbs Sampler) 소프트웨어를 활용한다. 특히, 공간적 상관관계(spatial correlation)를 고려하기 위해 GeoJAGS 확장 모듈과 CAR(Conditional Autoregressive) 모델을 사용한다. 이  세 가지 요소, DAGS, GEOJAGS, 그리고 Precision CAR는 . 본 연구의  방법론을 이해하는 데 중요한 역할을 한다.

DAG

DAG는 방향성 비순환 그래프(Directed Acyclic Graph)의 약자로, 확률 변수간의 의존 관계를 방향성 화살표(directed arrows)로 표현한 그래프이다. 각 노드(node)는 확률 변수를 나타내고, 화살표는 변수 간의 의존 관계를 나타낸다. 예를 들어, A -> B는 변수 B가 변수 A에 의존한다는 것을 의미한다. DAG는 베이지안 네트워크(Bayesian networks)를 시각적으로 표현하고 이해하는 데 유용하게 사용된다. 본 연구에서는 JAGS 모델의 구조, 즉 변수 간의 관계를 명확하게 파악하기 위해 DAG를 활용한다

그림 


GeoJAGS

GeoJAGS는 JAGS의 확장 모듈로서, 공간 통계 분석을 위한 기능을 제공한다. JeoJAGS는 특히 공간적 상관관계를 모델링하는 데 유용한 도구이다. 전염병 확산과 같이 공간적 패턴을 보이는 현상을 분석할 때, 지역 간의 지리적 근접성이나 인접성을 고려하는 것이 중요하다. GeoJAGS는 이러한 공간적 의존성을 모델에 반영할 수 있도록 다양한 함수를 제공한다. 본 연구에서는 공간적 상관관계를 모델링하기 위해 GeoJAGS에서 제공하는 preMatrixCAR 함수를 사용한다.


Precision CAR

CAR(conditional Autoregressive Model)는 공간적 상관관계를 모델링하기 위한 대표적인 통계 모델 중 하나이다. CAR 모델은 인접한 지역 간의 유사성(similarity)을 가정한다. 즉, 지리적으로 가까운 지역은 유사한 특성을 가질 가능성이 높다고 가정한다. Precision CAR 모델은 CAR 모델의 정밀도 행렬(precision matrix)을 사용하여 공간적 상관관계를 정의한다. 정밀도 행렬은 각 지역의 값이 인접 지역의 값에 조건부로 의존하는 방식을 나타낸다. 본 연구에서는 GeoJAGS의 prematrixCAR 함수를 통해 Precision CAR 모델을 구현하여 전염병 확산의 공간적 패턴을 모델링한다. 더불어, (D-pW)를 통해 인접행렬 W를 사용한다. D는 대각행렬로 각 지역의 이웃 수를 나타내고 p는 공간 상관관계의 강도를 나타내는 매개변수이다. 

이처럼 DAG는 모델의 구조를 한눈에 파악할 수 있도록 도와주며, GeoJAGS와 Precision CAR 모델은 JAGS에서 공간 통계 분석을 가능하게 하는 핵심 요소이다. 본 연구에서는 이러한 도구들을 활용하여 전염병 확산의 시공간적 패턴을 효과적으로 모델링하고 분석한다.


2.2 알고리즘 소개 




